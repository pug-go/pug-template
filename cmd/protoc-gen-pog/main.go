package main

import (
	"path"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

// TODO: Refactor

func main() {
	opts := protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			if len(file.Services) == 0 {
				continue
			}
			generateFiles(plugin, file)
		}
		return nil
	})
}

func generateFiles(plugin *protogen.Plugin, file *protogen.File) {
	protoPath := file.Desc.Path()
	base, _ := path.Split(strings.TrimSuffix(protoPath, path.Ext(protoPath)))
	dir := strings.ReplaceAll(base, "/", "")

	pkg := file.GoPackageName
	if strings.HasSuffix(string(pkg), "pb") {
		pkg = pkg[:len(pkg)-2]
	}

	serviceFilename := path.Join(dir, "service.go")
	serviceFile := plugin.NewGeneratedFile(serviceFilename, file.GoImportPath)

	writeHeader(serviceFile, protoPath, pkg)

	pbPkgName := string(file.GoPackageName)
	pbImportPath := string(file.GoImportPath)
	for _, service := range file.Services {
		genServiceStruct(serviceFile, service, pbPkgName, pbImportPath)
	}

	for _, service := range file.Services {
		for _, method := range service.Methods {
			methodFilename := path.Join(
				dir,
				toSnakeCase(method.GoName)+".go",
			)

			methodFile := plugin.NewGeneratedFile(methodFilename, file.GoImportPath)
			writeHeader(methodFile, protoPath, pkg)

			methodFile.P("import (")
			methodFile.P(`  "context"`)
			methodFile.P()
			methodFile.P("  ", pbPkgName, ` "`, pbImportPath, `"`)
			methodFile.P(")")
			methodFile.P()

			genMethod(methodFile, service, method, pbPkgName)
		}
	}
}

func writeHeader(
	file *protogen.GeneratedFile,
	protoPath string,
	pkg protogen.GoPackageName,
) {
	file.P("// Code generated by protoc-gen-pog, but you must modify it.")
	file.P("// source: " + protoPath)
	file.P()
	file.P("package ", pkg)
	file.P()
}

func genServiceStruct(
	file *protogen.GeneratedFile,
	service *protogen.Service,
	pbPkgName string,
	pbImportPath string,
) {
	serviceName := service.GoName + "Server"
	methodName := "New" + service.GoName

	file.P("import  ", pbPkgName, ` "`, pbImportPath, `"`)
	file.P("type ", serviceName, " struct {")
	file.P("  ", pbPkgName, ".Unimplemented", serviceName)
	file.P("  // add dependencies here (services, etc.)")
	file.P("}")
	file.P()
	file.P("// ", methodName, " TODO: Don't forget to register service in init.go")
	file.P("func ", methodName, "() *", serviceName, "{\n\treturn &", serviceName, "{}\n}")
	file.P()
}

func genMethod(
	file *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	pbPkgName string,
) {
	// Важно: тип сервера должен совпадать с тем, что мы сгенерили в service.go
	receiverType := service.GoName + "Server"
	recv := "h"

	// Типы сообщений — через QualifiedGoIdent, он сам добавит импорты при необходимости
	inputType := file.QualifiedGoIdent(method.Input.GoIdent)
	outputType := file.QualifiedGoIdent(method.Output.GoIdent)

	methodName := method.GoName

	file.P("func (", recv, " *", receiverType, ") ", methodName,
		"(ctx context.Context, req *", pbPkgName, ".", inputType, ") (*", pbPkgName, ".", outputType, ", error) {")
	file.P(`  // TODO: implement`)
	file.P(`  panic("not implemented")`)
	file.P("}")
	file.P()
}

func toSnakeCase(s string) string {
	var b strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				b.WriteByte('_')
			}
			b.WriteRune(unicode.ToLower(r))
		} else {
			b.WriteRune(r)
		}
	}
	return b.String()
}
